"""Centralized state management for the application"""
import json
import threading
from typing import Any, Dict, List, Optional, Callable
from PyQt6.QtCore import QObject, pyqtSignal
from pathlib import Path
from app.core.logger import logger

class StateManager(QObject):
    """Centralized application state management"""
    
    state_changed = pyqtSignal(str, object)  # key, new_value
    state_loaded = pyqtSignal(dict)  # entire_state
    state_saved = pyqtSignal(str)  # file_path
    
    def __init__(self, state_file: str = "app_state.json"):
        super().__init__()
        self.state_file = Path(state_file)
        self.state = {}
        self.subscribers = {}  # key -> list of callbacks
        self.lock = threading.RLock()
        self.auto_save = True
        self.save_timer = None
        
        # Initialize default state
        self._initialize_default_state()\n        \n        # Load existing state\n        self.load_state()\n    \n    def _initialize_default_state(self):\n        \"\"\"Initialize default application state\"\"\"\n        self.state = {\n            'ui': {\n                'theme': 'dark',\n                'window_geometry': None,\n                'window_state': None,\n                'current_page': 'home',\n                'sidebar_width': 300,\n                'font_size': 12\n            },\n            'scan': {\n                'current_target': '',\n                'last_scan_type': 'dns_enum',\n                'scan_history': [],\n                'active_scans': {},\n                'scan_settings': {\n                    'dns': {\n                        'timeout': 3,\n                        'max_workers': 50,\n                        'default_wordlist': None\n                    },\n                    'port': {\n                        'timeout': 5,\n                        'max_workers': 100,\n                        'default_ports': '1-1000'\n                    }\n                }\n            },\n            'session': {\n                'current_session_id': None,\n                'recent_sessions': [],\n                'auto_save_scans': True\n            },\n            'export': {\n                'default_format': 'json',\n                'export_directory': 'exports',\n                'include_metadata': True\n            },\n            'preferences': {\n                'auto_scroll_output': True,\n                'show_timestamps': False,\n                'confirm_destructive_actions': True,\n                'enable_notifications': True,\n                'minimize_to_tray': True\n            },\n            'cache': {\n                'enabled': True,\n                'ttl_seconds': 3600,\n                'max_size_mb': 100\n            },\n            'performance': {\n                'memory_threshold': 80,\n                'gc_threshold': 85,\n                'max_concurrent_scans': 5\n            }\n        }\n    \n    def get(self, key: str, default: Any = None) -> Any:\n        \"\"\"Get state value using dot notation\"\"\"\n        with self.lock:\n            keys = key.split('.')\n            value = self.state\n            \n            try:\n                for k in keys:\n                    value = value[k]\n                return value\n            except (KeyError, TypeError):\n                return default\n    \n    def set(self, key: str, value: Any, notify: bool = True) -> bool:\n        \"\"\"Set state value using dot notation\"\"\"\n        with self.lock:\n            keys = key.split('.')\n            state = self.state\n            \n            try:\n                # Navigate to parent dictionary\n                for k in keys[:-1]:\n                    if k not in state:\n                        state[k] = {}\n                    state = state[k]\n                \n                # Set the value\n                old_value = state.get(keys[-1])\n                state[keys[-1]] = value\n                \n                # Notify subscribers if value changed\n                if notify and old_value != value:\n                    self.state_changed.emit(key, value)\n                    self._notify_subscribers(key, value)\n                \n                # Auto-save if enabled\n                if self.auto_save:\n                    self._schedule_save()\n                \n                logger.debug(f\"State updated: {key} = {value}\")\n                return True\n                \n            except Exception as e:\n                logger.error(f\"Error setting state {key}: {e}\")\n                return False\n    \n    def update(self, updates: Dict[str, Any], notify: bool = True) -> bool:\n        \"\"\"Update multiple state values at once\"\"\"\n        try:\n            for key, value in updates.items():\n                self.set(key, value, notify=False)\n            \n            if notify:\n                # Emit single notification for batch update\n                self.state_changed.emit('batch_update', updates)\n                \n                # Notify individual subscribers\n                for key, value in updates.items():\n                    self._notify_subscribers(key, value)\n            \n            return True\n            \n        except Exception as e:\n            logger.error(f\"Error updating state: {e}\")\n            return False\n    \n    def delete(self, key: str, notify: bool = True) -> bool:\n        \"\"\"Delete state value\"\"\"\n        with self.lock:\n            keys = key.split('.')\n            state = self.state\n            \n            try:\n                # Navigate to parent dictionary\n                for k in keys[:-1]:\n                    state = state[k]\n                \n                # Delete the key\n                if keys[-1] in state:\n                    del state[keys[-1]]\n                    \n                    if notify:\n                        self.state_changed.emit(key, None)\n                        self._notify_subscribers(key, None)\n                    \n                    logger.debug(f\"State deleted: {key}\")\n                    return True\n                \n                return False\n                \n            except (KeyError, TypeError) as e:\n                logger.error(f\"Error deleting state {key}: {e}\")\n                return False\n    \n    def subscribe(self, key: str, callback: Callable[[Any], None]):\n        \"\"\"Subscribe to state changes for a specific key\"\"\"\n        with self.lock:\n            if key not in self.subscribers:\n                self.subscribers[key] = []\n            \n            if callback not in self.subscribers[key]:\n                self.subscribers[key].append(callback)\n                logger.debug(f\"Subscribed to state changes: {key}\")\n    \n    def unsubscribe(self, key: str, callback: Callable[[Any], None]):\n        \"\"\"Unsubscribe from state changes\"\"\"\n        with self.lock:\n            if key in self.subscribers and callback in self.subscribers[key]:\n                self.subscribers[key].remove(callback)\n                logger.debug(f\"Unsubscribed from state changes: {key}\")\n    \n    def _notify_subscribers(self, key: str, value: Any):\n        \"\"\"Notify subscribers of state changes\"\"\"\n        # Notify exact key subscribers\n        if key in self.subscribers:\n            for callback in self.subscribers[key]:\n                try:\n                    callback(value)\n                except Exception as e:\n                    logger.error(f\"Error in state subscriber callback: {e}\")\n        \n        # Notify wildcard subscribers (e.g., 'ui.*' for any ui change)\n        key_parts = key.split('.')\n        for i in range(len(key_parts)):\n            wildcard_key = '.'.join(key_parts[:i+1]) + '.*'\n            if wildcard_key in self.subscribers:\n                for callback in self.subscribers[wildcard_key]:\n                    try:\n                        callback(value)\n                    except Exception as e:\n                        logger.error(f\"Error in wildcard subscriber callback: {e}\")\n    \n    def load_state(self, file_path: Optional[str] = None) -> bool:\n        \"\"\"Load state from file\"\"\"\n        file_path = Path(file_path) if file_path else self.state_file\n        \n        try:\n            if file_path.exists():\n                with open(file_path, 'r', encoding='utf-8') as f:\n                    loaded_state = json.load(f)\n                \n                # Merge with default state to ensure all keys exist\n                self._merge_state(self.state, loaded_state)\n                \n                self.state_loaded.emit(self.state)\n                logger.info(f\"State loaded from {file_path}\")\n                return True\n            else:\n                logger.info(\"No existing state file found, using defaults\")\n                return True\n                \n        except Exception as e:\n            logger.error(f\"Error loading state from {file_path}: {e}\")\n            return False\n    \n    def save_state(self, file_path: Optional[str] = None) -> bool:\n        \"\"\"Save current state to file\"\"\"\n        file_path = Path(file_path) if file_path else self.state_file\n        \n        try:\n            # Ensure directory exists\n            file_path.parent.mkdir(parents=True, exist_ok=True)\n            \n            with self.lock:\n                # Create a copy to avoid modification during save\n                state_copy = json.loads(json.dumps(self.state, default=str))\n            \n            with open(file_path, 'w', encoding='utf-8') as f:\n                json.dump(state_copy, f, indent=2, default=str)\n            \n            self.state_saved.emit(str(file_path))\n            logger.info(f\"State saved to {file_path}\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Error saving state to {file_path}: {e}\")\n            return False\n    \n    def _merge_state(self, default: Dict, loaded: Dict):\n        \"\"\"Recursively merge loaded state with default state\"\"\"\n        for key, value in loaded.items():\n            if key in default and isinstance(default[key], dict) and isinstance(value, dict):\n                self._merge_state(default[key], value)\n            else:\n                default[key] = value\n    \n    def _schedule_save(self):\n        \"\"\"Schedule automatic state save\"\"\"\n        # Implement debounced saving to avoid excessive I/O\n        if self.save_timer:\n            self.save_timer.cancel()\n        \n        self.save_timer = threading.Timer(1.0, self.save_state)\n        self.save_timer.start()\n    \n    def get_state_summary(self) -> Dict[str, Any]:\n        \"\"\"Get summary of current state for debugging\"\"\"\n        with self.lock:\n            return {\n                'total_keys': self._count_keys(self.state),\n                'subscribers': {key: len(callbacks) for key, callbacks in self.subscribers.items()},\n                'auto_save': self.auto_save,\n                'state_file': str(self.state_file),\n                'main_sections': list(self.state.keys())\n            }\n    \n    def _count_keys(self, obj: Any) -> int:\n        \"\"\"Recursively count keys in nested dictionary\"\"\"\n        if isinstance(obj, dict):\n            return len(obj) + sum(self._count_keys(v) for v in obj.values())\n        return 0\n    \n    def reset_to_defaults(self, section: Optional[str] = None) -> bool:\n        \"\"\"Reset state to defaults\"\"\"\n        try:\n            if section:\n                # Reset specific section\n                default_state = {}\n                self._initialize_default_state()\n                if section in default_state:\n                    self.set(section, default_state[section])\n                    logger.info(f\"Reset {section} to defaults\")\n                else:\n                    logger.warning(f\"Unknown section: {section}\")\n                    return False\n            else:\n                # Reset entire state\n                self._initialize_default_state()\n                self.state_loaded.emit(self.state)\n                logger.info(\"Reset entire state to defaults\")\n            \n            if self.auto_save:\n                self.save_state()\n            \n            return True\n            \n        except Exception as e:\n            logger.error(f\"Error resetting state: {e}\")\n            return False\n    \n    def export_state(self, file_path: str, sections: Optional[List[str]] = None) -> bool:\n        \"\"\"Export state or specific sections to file\"\"\"\n        try:\n            export_data = {}\n            \n            if sections:\n                for section in sections:\n                    value = self.get(section)\n                    if value is not None:\n                        export_data[section] = value\n            else:\n                export_data = self.state\n            \n            with open(file_path, 'w', encoding='utf-8') as f:\n                json.dump(export_data, f, indent=2, default=str)\n            \n            logger.info(f\"State exported to {file_path}\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Error exporting state: {e}\")\n            return False\n    \n    def import_state(self, file_path: str, merge: bool = True) -> bool:\n        \"\"\"Import state from file\"\"\"\n        try:\n            with open(file_path, 'r', encoding='utf-8') as f:\n                imported_state = json.load(f)\n            \n            if merge:\n                # Merge with existing state\n                self._merge_state(self.state, imported_state)\n            else:\n                # Replace entire state\n                self.state = imported_state\n            \n            self.state_loaded.emit(self.state)\n            logger.info(f\"State imported from {file_path}\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Error importing state: {e}\")\n            return False\n\n# Global state manager instance\nstate_manager = StateManager()