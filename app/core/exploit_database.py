# app/core/exploit_database.py
import json
import sqlite3
import requests
from typing import Dict, List, Optional, Tuple
from datetime import datetime
from PyQt6.QtCore import QObject, pyqtSignal

class ExploitDatabase(QObject):
    """Professional exploit database with CVE integration"""
    
    exploit_event = pyqtSignal(str, str, dict)  # event_type, message, data
    
    def __init__(self, db_path: str = "exploits.db"):
        super().__init__()
        self.db_path = db_path
        self.init_database()
        
    def init_database(self):
        """Initialize exploit database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS exploits (
                id INTEGER PRIMARY KEY,
                cve_id TEXT UNIQUE,
                title TEXT,
                description TEXT,
                severity REAL,
                cvss_score REAL,
                exploit_code TEXT,
                metasploit_module TEXT,
                affected_systems TEXT,
                references TEXT,
                tags TEXT,
                created_date TEXT,
                updated_date TEXT
            )
        """)
        
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS exploit_categories (
                id INTEGER PRIMARY KEY,
                name TEXT UNIQUE,
                description TEXT
            )
        """)
        
        # Insert default categories
        categories = [
            ("Web Application", "Web-based vulnerabilities and exploits"),
            ("Network Services", "Network service exploits and attacks"),
            ("Operating System", "OS-level vulnerabilities and privilege escalation"),
            ("Database", "Database-specific attacks and injections"),
            ("Wireless", "Wireless network attacks and exploits"),
            ("Social Engineering", "Human-based attack vectors"),
            ("Physical", "Physical security bypasses and attacks")
        ]
        
        cursor.executemany("""
            INSERT OR IGNORE INTO exploit_categories (name, description) 
            VALUES (?, ?)
        """, categories)
        
        conn.commit()
        conn.close()
        
    def add_exploit(self, exploit_data: Dict) -> bool:
        """Add exploit to database"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute("""
                INSERT OR REPLACE INTO exploits 
                (cve_id, title, description, severity, cvss_score, exploit_code, 
                 metasploit_module, affected_systems, references, tags, 
                 created_date, updated_date)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                exploit_data.get('cve_id'),
                exploit_data.get('title'),
                exploit_data.get('description'),
                exploit_data.get('severity', 0.0),
                exploit_data.get('cvss_score', 0.0),
                exploit_data.get('exploit_code', ''),
                exploit_data.get('metasploit_module', ''),
                json.dumps(exploit_data.get('affected_systems', [])),
                json.dumps(exploit_data.get('references', [])),
                json.dumps(exploit_data.get('tags', [])),
                datetime.now().isoformat(),
                datetime.now().isoformat()
            ))
            
            conn.commit()
            conn.close()
            
            self.exploit_event.emit('exploit_added', f'Added exploit: {exploit_data.get("cve_id")}', exploit_data)
            return True
            
        except Exception as e:
            self.exploit_event.emit('error', f'Failed to add exploit: {str(e)}', {})
            return False
            
    def search_exploits(self, query: str, category: str = None, 
                       min_severity: float = 0.0) -> List[Dict]:
        """Search exploits by query, category, and severity"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        sql = """
            SELECT * FROM exploits 
            WHERE (title LIKE ? OR description LIKE ? OR cve_id LIKE ?)
            AND severity >= ?
        """
        params = [f"%{query}%", f"%{query}%", f"%{query}%", min_severity]
        
        if category:
            sql += " AND tags LIKE ?"
            params.append(f"%{category}%")
            
        sql += " ORDER BY severity DESC, cvss_score DESC"
        
        cursor.execute(sql, params)
        results = cursor.fetchall()
        conn.close()
        
        exploits = []
        for row in results:
            exploit = {
                'id': row[0],
                'cve_id': row[1],
                'title': row[2],
                'description': row[3],
                'severity': row[4],
                'cvss_score': row[5],
                'exploit_code': row[6],
                'metasploit_module': row[7],
                'affected_systems': json.loads(row[8] or '[]'),
                'references': json.loads(row[9] or '[]'),
                'tags': json.loads(row[10] or '[]'),
                'created_date': row[11],
                'updated_date': row[12]
            }
            exploits.append(exploit)
            
        return exploits
        
    def get_exploit_by_cve(self, cve_id: str) -> Optional[Dict]:
        """Get specific exploit by CVE ID"""
        exploits = self.search_exploits(cve_id)
        return exploits[0] if exploits else None
        
    def update_from_nvd(self, api_key: str = None) -> int:
        """Update database from National Vulnerability Database"""
        try:
            # NVD API endpoint
            url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
            headers = {}
            
            if api_key:
                headers['apiKey'] = api_key
                
            # Get recent CVEs with high severity
            params = {
                'cvssV3Severity': 'HIGH,CRITICAL',
                'resultsPerPage': 100
            }
            
            response = requests.get(url, headers=headers, params=params, timeout=30)
            response.raise_for_status()
            
            data = response.json()
            added_count = 0
            
            for cve_item in data.get('vulnerabilities', []):
                cve = cve_item.get('cve', {})
                cve_id = cve.get('id')
                
                if not cve_id:
                    continue
                    
                # Extract CVE data
                description = ""
                if cve.get('descriptions'):
                    description = cve['descriptions'][0].get('value', '')
                    
                cvss_score = 0.0
                severity = 0.0
                
                metrics = cve.get('metrics', {})
                if 'cvssMetricV31' in metrics:
                    cvss_data = metrics['cvssMetricV31'][0]['cvssData']
                    cvss_score = cvss_data.get('baseScore', 0.0)
                    severity = cvss_score / 10.0
                    
                references = []
                for ref in cve.get('references', []):
                    references.append(ref.get('url', ''))
                    
                exploit_data = {
                    'cve_id': cve_id,
                    'title': f"CVE {cve_id}",
                    'description': description,
                    'severity': severity,
                    'cvss_score': cvss_score,
                    'references': references,
                    'tags': ['nvd', 'cve'],
                    'affected_systems': []
                }
                
                if self.add_exploit(exploit_data):
                    added_count += 1
                    
            self.exploit_event.emit('database_updated', f'Added {added_count} new exploits from NVD', 
                                  {'count': added_count})
            return added_count
            
        except Exception as e:
            self.exploit_event.emit('error', f'Failed to update from NVD: {str(e)}', {})
            return 0
            
    def get_exploits_for_service(self, service: str, version: str = None) -> List[Dict]:
        """Get exploits targeting specific service/version"""
        query = service
        if version:
            query += f" {version}"
            
        return self.search_exploits(query, min_severity=0.5)
        
    def generate_exploit_report(self, target_info: Dict) -> Dict:
        """Generate exploit recommendations based on target info"""
        recommendations = []
        
        # Analyze open ports and services
        for port_info in target_info.get('open_ports', []):
            service = port_info.get('service', '')
            version = port_info.get('version', '')
            
            if service:
                exploits = self.get_exploits_for_service(service, version)
                for exploit in exploits[:3]:  # Top 3 exploits per service
                    recommendations.append({
                        'target_service': f"{service} {version}".strip(),
                        'target_port': port_info.get('port'),
                        'exploit': exploit,
                        'risk_level': self._calculate_risk_level(exploit, port_info)
                    })
                    
        # Sort by risk level
        recommendations.sort(key=lambda x: x['risk_level'], reverse=True)
        
        return {
            'target': target_info.get('target', 'Unknown'),
            'scan_date': datetime.now().isoformat(),
            'total_recommendations': len(recommendations),
            'high_risk_count': len([r for r in recommendations if r['risk_level'] > 0.8]),
            'recommendations': recommendations[:10]  # Top 10 recommendations
        }
        
    def _calculate_risk_level(self, exploit: Dict, port_info: Dict) -> float:
        """Calculate risk level for exploit recommendation"""
        base_risk = exploit.get('severity', 0.0)
        
        # Increase risk for commonly targeted ports
        high_value_ports = [22, 80, 443, 3389, 21, 25, 135, 139, 445]
        if port_info.get('port') in high_value_ports:
            base_risk += 0.2
            
        # Increase risk if service version is detected
        if port_info.get('version'):
            base_risk += 0.1
            
        return min(1.0, base_risk)
        
    def get_database_stats(self) -> Dict:
        """Get database statistics"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("SELECT COUNT(*) FROM exploits")
        total_exploits = cursor.fetchone()[0]
        
        cursor.execute("SELECT COUNT(*) FROM exploits WHERE severity >= 0.8")
        high_severity = cursor.fetchone()[0]
        
        cursor.execute("SELECT COUNT(*) FROM exploits WHERE metasploit_module != ''")
        with_metasploit = cursor.fetchone()[0]
        
        cursor.execute("SELECT AVG(cvss_score) FROM exploits WHERE cvss_score > 0")
        avg_cvss = cursor.fetchone()[0] or 0.0
        
        conn.close()
        
        return {
            'total_exploits': total_exploits,
            'high_severity_count': high_severity,
            'metasploit_modules': with_metasploit,
            'average_cvss_score': round(avg_cvss, 2)
        }

# Global exploit database instance
exploit_database = ExploitDatabase()