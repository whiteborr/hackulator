"""Security management and credential handling"""
import os\nimport base64\nimport hashlib\nimport secrets\nfrom typing import Dict, Optional, Tuple, List\nfrom pathlib import Path\nfrom cryptography.fernet import Fernet\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\nfrom PyQt6.QtCore import QObject, pyqtSignal\nfrom app.core.logger import logger\n\nclass SecurityManager(QObject):\n    \"\"\"Manage security features and credential storage\"\"\"\n    \n    security_event = pyqtSignal(str, str)  # event_type, message\n    \n    def __init__(self, credentials_file: str = \"credentials.enc\"):\n        super().__init__()\n        self.credentials_file = Path(credentials_file)\n        self.master_key = None\n        self.cipher_suite = None\n        self.session_token = None\n        \n        # Security settings\n        self.max_login_attempts = 3\n        self.login_attempts = 0\n        self.account_locked = False\n        \n        # Initialize session\n        self._generate_session_token()\n    \n    def _generate_session_token(self):\n        \"\"\"Generate secure session token\"\"\"\n        self.session_token = secrets.token_urlsafe(32)\n        logger.debug(\"Session token generated\")\n    \n    def initialize_encryption(self, password: str) -> bool:\n        \"\"\"Initialize encryption with master password\"\"\"\n        try:\n            # Generate salt\n            salt = os.urandom(16)\n            \n            # Derive key from password\n            kdf = PBKDF2HMAC(\n                algorithm=hashes.SHA256(),\n                length=32,\n                salt=salt,\n                iterations=100000,\n            )\n            key = base64.urlsafe_b64encode(kdf.derive(password.encode()))\n            \n            # Create cipher suite\n            self.cipher_suite = Fernet(key)\n            self.master_key = key\n            \n            # Store salt for future use\n            self._store_salt(salt)\n            \n            logger.info(\"Encryption initialized successfully\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Error initializing encryption: {e}\")\n            return False\n    \n    def unlock_with_password(self, password: str) -> bool:\n        \"\"\"Unlock credential storage with password\"\"\"\n        if self.account_locked:\n            self.security_event.emit('account_locked', 'Account is locked due to too many failed attempts')\n            return False\n        \n        try:\n            # Load salt\n            salt = self._load_salt()\n            if not salt:\n                logger.error(\"No salt found - encryption not initialized\")\n                return False\n            \n            # Derive key from password\n            kdf = PBKDF2HMAC(\n                algorithm=hashes.SHA256(),\n                length=32,\n                salt=salt,\n                iterations=100000,\n            )\n            key = base64.urlsafe_b64encode(kdf.derive(password.encode()))\n            \n            # Test decryption with a known value\n            test_cipher = Fernet(key)\n            if self._test_decryption(test_cipher):\n                self.cipher_suite = test_cipher\n                self.master_key = key\n                self.login_attempts = 0\n                logger.info(\"Credentials unlocked successfully\")\n                self.security_event.emit('unlock_success', 'Credentials unlocked')\n                return True\n            else:\n                self.login_attempts += 1\n                if self.login_attempts >= self.max_login_attempts:\n                    self.account_locked = True\n                    self.security_event.emit('account_locked', 'Account locked due to failed attempts')\n                else:\n                    remaining = self.max_login_attempts - self.login_attempts\n                    self.security_event.emit('unlock_failed', f'Invalid password. {remaining} attempts remaining')\n                return False\n                \n        except Exception as e:\n            logger.error(f\"Error unlocking credentials: {e}\")\n            self.login_attempts += 1\n            return False\n    \n    def _store_salt(self, salt: bytes):\n        \"\"\"Store encryption salt securely\"\"\"\n        try:\n            salt_file = self.credentials_file.with_suffix('.salt')\n            with open(salt_file, 'wb') as f:\n                f.write(salt)\n        except Exception as e:\n            logger.error(f\"Error storing salt: {e}\")\n    \n    def _load_salt(self) -> Optional[bytes]:\n        \"\"\"Load encryption salt\"\"\"\n        try:\n            salt_file = self.credentials_file.with_suffix('.salt')\n            if salt_file.exists():\n                with open(salt_file, 'rb') as f:\n                    return f.read()\n        except Exception as e:\n            logger.error(f\"Error loading salt: {e}\")\n        return None\n    \n    def _test_decryption(self, cipher_suite: Fernet) -> bool:\n        \"\"\"Test if cipher suite can decrypt stored data\"\"\"\n        try:\n            if not self.credentials_file.exists():\n                # No credentials file exists, so password is correct by default\n                return True\n            \n            # Try to load and decrypt credentials\n            with open(self.credentials_file, 'rb') as f:\n                encrypted_data = f.read()\n            \n            if not encrypted_data:\n                return True\n            \n            # Attempt decryption\n            cipher_suite.decrypt(encrypted_data)\n            return True\n            \n        except Exception:\n            return False\n    \n    def store_credential(self, service: str, username: str, password: str) -> bool:\n        \"\"\"Store encrypted credential\"\"\"\n        if not self.cipher_suite:\n            logger.error(\"Encryption not initialized\")\n            return False\n        \n        try:\n            # Load existing credentials\n            credentials = self._load_credentials()\n            \n            # Add new credential\n            credentials[service] = {\n                'username': username,\n                'password': password,\n                'created': self._get_timestamp(),\n                'last_used': None\n            }\n            \n            # Save encrypted credentials\n            return self._save_credentials(credentials)\n            \n        except Exception as e:\n            logger.error(f\"Error storing credential: {e}\")\n            return False\n    \n    def get_credential(self, service: str) -> Optional[Tuple[str, str]]:\n        \"\"\"Get decrypted credential\"\"\"\n        if not self.cipher_suite:\n            logger.error(\"Encryption not initialized\")\n            return None\n        \n        try:\n            credentials = self._load_credentials()\n            \n            if service in credentials:\n                cred = credentials[service]\n                # Update last used timestamp\n                cred['last_used'] = self._get_timestamp()\n                self._save_credentials(credentials)\n                \n                return cred['username'], cred['password']\n            \n            return None\n            \n        except Exception as e:\n            logger.error(f\"Error retrieving credential: {e}\")\n            return None\n    \n    def delete_credential(self, service: str) -> bool:\n        \"\"\"Delete stored credential\"\"\"\n        if not self.cipher_suite:\n            logger.error(\"Encryption not initialized\")\n            return False\n        \n        try:\n            credentials = self._load_credentials()\n            \n            if service in credentials:\n                del credentials[service]\n                return self._save_credentials(credentials)\n            \n            return True\n            \n        except Exception as e:\n            logger.error(f\"Error deleting credential: {e}\")\n            return False\n    \n    def list_services(self) -> List[str]:\n        \"\"\"List all stored services\"\"\"\n        if not self.cipher_suite:\n            return []\n        \n        try:\n            credentials = self._load_credentials()\n            return list(credentials.keys())\n        except Exception as e:\n            logger.error(f\"Error listing services: {e}\")\n            return []\n    \n    def _load_credentials(self) -> Dict:\n        \"\"\"Load and decrypt credentials\"\"\"\n        try:\n            if not self.credentials_file.exists():\n                return {}\n            \n            with open(self.credentials_file, 'rb') as f:\n                encrypted_data = f.read()\n            \n            if not encrypted_data:\n                return {}\n            \n            decrypted_data = self.cipher_suite.decrypt(encrypted_data)\n            import json\n            return json.loads(decrypted_data.decode())\n            \n        except Exception as e:\n            logger.error(f\"Error loading credentials: {e}\")\n            return {}\n    \n    def _save_credentials(self, credentials: Dict) -> bool:\n        \"\"\"Encrypt and save credentials\"\"\"\n        try:\n            import json\n            json_data = json.dumps(credentials, indent=2)\n            encrypted_data = self.cipher_suite.encrypt(json_data.encode())\n            \n            # Ensure directory exists\n            self.credentials_file.parent.mkdir(parents=True, exist_ok=True)\n            \n            with open(self.credentials_file, 'wb') as f:\n                f.write(encrypted_data)\n            \n            logger.debug(\"Credentials saved successfully\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Error saving credentials: {e}\")\n            return False\n    \n    def _get_timestamp(self) -> str:\n        \"\"\"Get current timestamp\"\"\"\n        import datetime\n        return datetime.datetime.now().isoformat()\n    \n    def sanitize_output(self, text: str) -> str:\n        \"\"\"Sanitize output text for security\"\"\"\n        if not text:\n            return \"\"\n        \n        # Remove potential credential leaks\n        sensitive_patterns = [\n            r'password[\\s]*[:=][\\s]*[^\\s]+',\n            r'pass[\\s]*[:=][\\s]*[^\\s]+',\n            r'secret[\\s]*[:=][\\s]*[^\\s]+',\n            r'token[\\s]*[:=][\\s]*[^\\s]+',\n            r'key[\\s]*[:=][\\s]*[^\\s]+'\n        ]\n        \n        import re\n        sanitized = text\n        for pattern in sensitive_patterns:\n            sanitized = re.sub(pattern, '[REDACTED]', sanitized, flags=re.IGNORECASE)\n        \n        return sanitized\n    \n    def validate_secure_input(self, input_text: str) -> Tuple[bool, str]:\n        \"\"\"Validate input for security issues\"\"\"\n        if not input_text:\n            return True, \"Input is empty\"\n        \n        # Check for injection patterns\n        dangerous_patterns = [\n            r'[;&|`$(){}\\[\\]<>]',  # Command injection\n            r'(union|select|insert|update|delete|drop)\\s',  # SQL injection\n            r'<script|javascript:|data:|vbscript:',  # XSS\n            r'\\.\\.[\\/\\\\]',  # Path traversal\n        ]\n        \n        import re\n        for pattern in dangerous_patterns:\n            if re.search(pattern, input_text, re.IGNORECASE):\n                return False, f\"Input contains potentially dangerous content: {pattern}\"\n        \n        return True, \"Input is safe\"\n    \n    def generate_secure_password(self, length: int = 16) -> str:\n        \"\"\"Generate cryptographically secure password\"\"\"\n        import string\n        alphabet = string.ascii_letters + string.digits + \"!@#$%^&*\"\n        return ''.join(secrets.choice(alphabet) for _ in range(length))\n    \n    def hash_sensitive_data(self, data: str) -> str:\n        \"\"\"Hash sensitive data for logging/storage\"\"\"\n        return hashlib.sha256(data.encode()).hexdigest()[:16] + \"...\"\n    \n    def is_locked(self) -> bool:\n        \"\"\"Check if account is locked\"\"\"\n        return self.account_locked\n    \n    def unlock_account(self, admin_password: str) -> bool:\n        \"\"\"Unlock account with admin password\"\"\"\n        # This would typically verify against a separate admin credential\n        # For now, we'll use a simple check\n        admin_hash = \"admin_unlock_key\"  # In production, this would be properly secured\n        \n        if hashlib.sha256(admin_password.encode()).hexdigest().startswith(admin_hash[:8]):\n            self.account_locked = False\n            self.login_attempts = 0\n            self.security_event.emit('account_unlocked', 'Account unlocked by administrator')\n            return True\n        \n        return False\n    \n    def get_security_status(self) -> Dict:\n        \"\"\"Get current security status\"\"\"\n        return {\n            'encryption_initialized': self.cipher_suite is not None,\n            'account_locked': self.account_locked,\n            'login_attempts': self.login_attempts,\n            'max_attempts': self.max_login_attempts,\n            'session_active': self.session_token is not None,\n            'credentials_file_exists': self.credentials_file.exists(),\n            'stored_services': len(self.list_services())\n        }\n\n# Global security manager instance\nsecurity_manager = SecurityManager()