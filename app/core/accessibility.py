"""Accessibility enhancements for the application"""
from PyQt6.QtWidgets import QWidget, QApplication
from PyQt6.QtCore import QObject, pyqtSignal, QTimer
from PyQt6.QtGui import QKeySequence, QShortcut, QAccessible
from typing import Dict, List, Optional
from app.core.logger import logger

class AccessibilityManager(QObject):
    """Manage accessibility features and keyboard navigation"""
    
    focus_changed = pyqtSignal(QWidget)  # widget
    shortcut_activated = pyqtSignal(str)  # shortcut_name
    
    def __init__(self):
        super().__init__()
        self.shortcuts = {}
        self.focus_history = []
        self.max_focus_history = 10
        self.screen_reader_enabled = False
        
        # Connect to application focus changes
        app = QApplication.instance()
        if app:
            app.focusChanged.connect(self._on_focus_changed)
    
    def register_global_shortcuts(self, parent_widget: QWidget):
        """Register global keyboard shortcuts"""
        shortcuts_config = {
            # Navigation shortcuts
            'home': ('Alt+H', 'Navigate to home page'),
            'back': ('Escape', 'Go back to previous page'),
            'next_tab': ('Ctrl+Tab', 'Switch to next tab'),
            'prev_tab': ('Ctrl+Shift+Tab', 'Switch to previous tab'),
            
            # Action shortcuts
            'run_scan': ('F5', 'Start/stop current scan'),
            'export': ('Ctrl+E', 'Export current results'),
            'clear_output': ('Ctrl+L', 'Clear terminal output'),
            'save': ('Ctrl+S', 'Save current work'),
            
            # View shortcuts
            'toggle_theme': ('Ctrl+T', 'Toggle between light/dark theme'),
            'fullscreen': ('F11', 'Toggle fullscreen mode'),
            'zoom_in': ('Ctrl++', 'Increase font size'),
            'zoom_out': ('Ctrl+-', 'Decrease font size'),
            'reset_zoom': ('Ctrl+0', 'Reset font size'),
            
            # Help shortcuts\n            'help': ('F1', 'Show help dialog'),\n            'shortcuts': ('Ctrl+?', 'Show keyboard shortcuts'),\n            \n            # Accessibility shortcuts\n            'focus_next': ('Tab', 'Move focus to next element'),\n            'focus_prev': ('Shift+Tab', 'Move focus to previous element'),\n            'activate': ('Space', 'Activate focused element'),\n            'context_menu': ('Menu', 'Open context menu for focused element')\n        }\n        \n        for name, (key_sequence, description) in shortcuts_config.items():\n            try:\n                shortcut = QShortcut(QKeySequence(key_sequence), parent_widget)\n                shortcut.activated.connect(lambda n=name: self._shortcut_activated(n))\n                \n                self.shortcuts[name] = {\n                    'shortcut': shortcut,\n                    'key_sequence': key_sequence,\n                    'description': description,\n                    'enabled': True\n                }\n                \n                logger.debug(f\"Registered shortcut: {name} ({key_sequence})\")\n                \n            except Exception as e:\n                logger.error(f\"Failed to register shortcut {name}: {e}\")\n    \n    def _shortcut_activated(self, shortcut_name: str):\n        \"\"\"Handle shortcut activation\"\"\"\n        if shortcut_name in self.shortcuts and self.shortcuts[shortcut_name]['enabled']:\n            logger.debug(f\"Shortcut activated: {shortcut_name}\")\n            self.shortcut_activated.emit(shortcut_name)\n            \n            # Announce to screen reader if enabled\n            if self.screen_reader_enabled:\n                description = self.shortcuts[shortcut_name]['description']\n                self._announce_to_screen_reader(f\"Activated: {description}\")\n    \n    def _on_focus_changed(self, old_widget: QWidget, new_widget: QWidget):\n        \"\"\"Handle focus changes for accessibility\"\"\"\n        if new_widget:\n            # Add to focus history\n            self.focus_history.append(new_widget)\n            if len(self.focus_history) > self.max_focus_history:\n                self.focus_history.pop(0)\n            \n            self.focus_changed.emit(new_widget)\n            \n            # Announce focus change to screen reader\n            if self.screen_reader_enabled:\n                self._announce_focus_change(new_widget)\n    \n    def _announce_focus_change(self, widget: QWidget):\n        \"\"\"Announce focus change to screen reader\"\"\"\n        try:\n            # Get widget description for screen reader\n            widget_text = self._get_widget_description(widget)\n            if widget_text:\n                self._announce_to_screen_reader(f\"Focused: {widget_text}\")\n        except Exception as e:\n            logger.error(f\"Error announcing focus change: {e}\")\n    \n    def _get_widget_description(self, widget: QWidget) -> str:\n        \"\"\"Get accessible description of widget\"\"\"\n        descriptions = []\n        \n        # Try various methods to get widget description\n        if hasattr(widget, 'text') and widget.text():\n            descriptions.append(widget.text())\n        \n        if hasattr(widget, 'toolTip') and widget.toolTip():\n            descriptions.append(widget.toolTip())\n        \n        if hasattr(widget, 'statusTip') and widget.statusTip():\n            descriptions.append(widget.statusTip())\n        \n        if hasattr(widget, 'whatsThis') and widget.whatsThis():\n            descriptions.append(widget.whatsThis())\n        \n        # Get object name as fallback\n        if widget.objectName():\n            descriptions.append(widget.objectName())\n        \n        # Get class name as last resort\n        if not descriptions:\n            descriptions.append(widget.__class__.__name__)\n        \n        return ' - '.join(descriptions)\n    \n    def _announce_to_screen_reader(self, message: str):\n        \"\"\"Announce message to screen reader\"\"\"\n        try:\n            # Use Qt's accessibility system\n            QAccessible.updateAccessibility(QAccessible.Event.Announcement)\n            logger.debug(f\"Screen reader announcement: {message}\")\n        except Exception as e:\n            logger.error(f\"Error announcing to screen reader: {e}\")\n    \n    def enable_screen_reader_support(self, enabled: bool = True):\n        \"\"\"Enable or disable screen reader support\"\"\"\n        self.screen_reader_enabled = enabled\n        logger.info(f\"Screen reader support {'enabled' if enabled else 'disabled'}\")\n    \n    def set_shortcut_enabled(self, shortcut_name: str, enabled: bool):\n        \"\"\"Enable or disable a specific shortcut\"\"\"\n        if shortcut_name in self.shortcuts:\n            self.shortcuts[shortcut_name]['enabled'] = enabled\n            self.shortcuts[shortcut_name]['shortcut'].setEnabled(enabled)\n            logger.debug(f\"Shortcut {shortcut_name} {'enabled' if enabled else 'disabled'}\")\n    \n    def get_shortcuts_help(self) -> Dict[str, Dict[str, str]]:\n        \"\"\"Get help information for all shortcuts\"\"\"\n        help_info = {}\n        \n        categories = {\n            'Navigation': ['home', 'back', 'next_tab', 'prev_tab'],\n            'Actions': ['run_scan', 'export', 'clear_output', 'save'],\n            'View': ['toggle_theme', 'fullscreen', 'zoom_in', 'zoom_out', 'reset_zoom'],\n            'Help': ['help', 'shortcuts'],\n            'Accessibility': ['focus_next', 'focus_prev', 'activate', 'context_menu']\n        }\n        \n        for category, shortcut_names in categories.items():\n            help_info[category] = {}\n            for name in shortcut_names:\n                if name in self.shortcuts:\n                    shortcut_info = self.shortcuts[name]\n                    help_info[category][shortcut_info['key_sequence']] = shortcut_info['description']\n        \n        return help_info\n    \n    def focus_previous_widget(self):\n        \"\"\"Focus the previous widget in history\"\"\"\n        if len(self.focus_history) >= 2:\n            # Get the widget before the current one\n            previous_widget = self.focus_history[-2]\n            if previous_widget and not previous_widget.isHidden():\n                previous_widget.setFocus()\n                return True\n        return False\n    \n    def enhance_widget_accessibility(self, widget: QWidget, \n                                   description: str = None,\n                                   role: str = None):\n        \"\"\"Enhance a widget's accessibility properties\"\"\"\n        try:\n            # Set accessible name and description\n            if description:\n                widget.setAccessibleDescription(description)\n            \n            # Set tool tip if not already set\n            if description and not widget.toolTip():\n                widget.setToolTip(description)\n            \n            # Ensure widget can receive focus if it's interactive\n            interactive_types = ['QPushButton', 'QLineEdit', 'QComboBox', 'QCheckBox', 'QRadioButton']\n            if widget.__class__.__name__ in interactive_types:\n                widget.setFocusPolicy(widget.focusPolicy() | widget.FocusPolicy.TabFocus)\n            \n            logger.debug(f\"Enhanced accessibility for {widget.__class__.__name__}\")\n            \n        except Exception as e:\n            logger.error(f\"Error enhancing widget accessibility: {e}\")\n    \n    def create_skip_links(self, parent_widget: QWidget, skip_targets: Dict[str, QWidget]):\n        \"\"\"Create skip navigation links for accessibility\"\"\"\n        # This would typically be implemented as invisible buttons\n        # that become visible when focused, allowing keyboard users\n        # to skip to main content areas\n        pass\n\n# Global accessibility manager instance\naccessibility_manager = AccessibilityManager()