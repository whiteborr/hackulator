# app/core/vulnerability_correlator.py
import re
from collections import defaultdict
from typing import Dict, List, Tuple

class VulnerabilityCorrelator:
    """Correlate findings across different scan types"""
    
    def __init__(self):
        self.correlation_rules = {
            'subdomain_exposure': {
                'patterns': ['admin', 'test', 'dev', 'staging', 'backup', 'api', 'mail'],
                'risk': 'high',
                'description': 'Sensitive subdomain exposure increases attack surface'
            },
            'common_ports': {
                'patterns': ['80', '443', '22', '21', '25', '53', '3389'],
                'risk': 'medium',
                'description': 'Common service ports may indicate standard configurations'
            },
            'database_exposure': {
                'patterns': ['mysql', 'postgres', 'mongo', 'redis', '3306', '5432', '27017'],
                'risk': 'critical',
                'description': 'Database services exposed to network'
            },
            'admin_interfaces': {
                'patterns': ['admin', 'phpmyadmin', 'wp-admin', 'cpanel', 'webmin'],
                'risk': 'high',
                'description': 'Administrative interfaces accessible'
            }
        }
        
    def correlate_findings(self, scan_results: Dict) -> Dict:
        """Correlate findings across multiple scan types"""
        correlations = {
            'attack_chains': [],
            'risk_amplifiers': [],
            'security_gaps': [],
            'correlation_score': 0
        }
        
        # Extract all findings into a unified format
        all_findings = self._extract_findings(scan_results)
        
        # Find correlations
        correlations['attack_chains'] = self._find_attack_chains(all_findings)
        correlations['risk_amplifiers'] = self._find_risk_amplifiers(all_findings)
        correlations['security_gaps'] = self._find_security_gaps(all_findings)
        correlations['correlation_score'] = self._calculate_correlation_score(correlations)
        
        return correlations
    
    def _extract_findings(self, scan_results: Dict) -> List[Dict]:
        """Extract and normalize findings from different scan types"""
        findings = []
        
        for scan_type, results in scan_results.items():
            if scan_type == 'dns_enum' and isinstance(results, dict):
                for domain, records in results.items():
                    findings.append({
                        'type': 'subdomain',
                        'value': domain,
                        'source': 'dns_enum',
                        'details': records
                    })
            elif scan_type == 'port_scan' and isinstance(results, dict):
                if 'ports' in results:
                    for port in results['ports']:
                        findings.append({
                            'type': 'open_port',
                            'value': str(port),
                            'source': 'port_scan',
                            'details': results
                        })
        
        return findings
    
    def _find_attack_chains(self, findings: List[Dict]) -> List[Dict]:
        """Identify potential attack chains"""
        chains = []
        
        # Look for subdomain + port combinations
        subdomains = [f for f in findings if f['type'] == 'subdomain']
        ports = [f for f in findings if f['type'] == 'open_port']
        
        for subdomain in subdomains:
            domain_name = subdomain['value'].lower()
            
            # Check for admin subdomains with common admin ports
            if any(pattern in domain_name for pattern in ['admin', 'manage', 'control']):
                admin_ports = [p for p in ports if p['value'] in ['80', '443', '8080', '8443']]
                if admin_ports:
                    chains.append({
                        'chain_type': 'admin_access',
                        'risk': 'high',
                        'description': f'Admin subdomain {domain_name} with web services exposed',
                        'components': [subdomain, admin_ports[0]],
                        'impact': 'Administrative access may be possible'
                    })
            
            # Check for database subdomains with database ports
            if any(pattern in domain_name for pattern in ['db', 'database', 'sql']):
                db_ports = [p for p in ports if p['value'] in ['3306', '5432', '1433', '27017']]
                if db_ports:
                    chains.append({
                        'chain_type': 'database_access',
                        'risk': 'critical',
                        'description': f'Database subdomain {domain_name} with database ports exposed',
                        'components': [subdomain, db_ports[0]],
                        'impact': 'Direct database access may be possible'
                    })
        
        return chains
    
    def _find_risk_amplifiers(self, findings: List[Dict]) -> List[Dict]:
        """Find findings that amplify overall risk"""
        amplifiers = []
        
        # Count sensitive subdomains
        sensitive_subdomains = []
        for finding in findings:
            if finding['type'] == 'subdomain':
                domain = finding['value'].lower()
                for rule_name, rule in self.correlation_rules.items():
                    if any(pattern in domain for pattern in rule['patterns']):
                        sensitive_subdomains.append({
                            'finding': finding,
                            'rule': rule_name,
                            'risk': rule['risk']
                        })
        
        if len(sensitive_subdomains) > 3:
            amplifiers.append({
                'type': 'multiple_sensitive_subdomains',
                'risk': 'high',
                'count': len(sensitive_subdomains),
                'description': f'{len(sensitive_subdomains)} sensitive subdomains increase attack surface',
                'impact': 'Multiple entry points for attackers'
            })
        
        # Check for common port patterns
        open_ports = [f['value'] for f in findings if f['type'] == 'open_port']
        common_ports = ['22', '80', '443', '21', '25']
        common_found = [p for p in open_ports if p in common_ports]
        
        if len(common_found) > 3:
            amplifiers.append({
                'type': 'multiple_common_services',
                'risk': 'medium',
                'count': len(common_found),
                'description': f'{len(common_found)} common services exposed',
                'impact': 'Standard attack vectors available'
            })
        
        return amplifiers
    
    def _find_security_gaps(self, findings: List[Dict]) -> List[Dict]:
        """Identify potential security gaps"""
        gaps = []
        
        # Check for missing security headers (if web services found)
        web_ports = [f for f in findings if f['type'] == 'open_port' and f['value'] in ['80', '443']]
        if web_ports:
            gaps.append({
                'type': 'web_security_headers',
                'risk': 'medium',
                'description': 'Web services detected - security headers should be verified',
                'recommendation': 'Implement security headers (HSTS, CSP, X-Frame-Options)'
            })
        
        # Check for SSH exposure
        ssh_ports = [f for f in findings if f['type'] == 'open_port' and f['value'] == '22']
        if ssh_ports:
            gaps.append({
                'type': 'ssh_exposure',
                'risk': 'medium',
                'description': 'SSH service exposed to network',
                'recommendation': 'Restrict SSH access and use key-based authentication'
            })
        
        return gaps
    
    def _calculate_correlation_score(self, correlations: Dict) -> int:
        """Calculate overall correlation risk score"""
        score = 0
        
        # Attack chains contribute most to score
        for chain in correlations['attack_chains']:
            if chain['risk'] == 'critical':
                score += 10
            elif chain['risk'] == 'high':
                score += 7
            elif chain['risk'] == 'medium':
                score += 4
        
        # Risk amplifiers
        for amp in correlations['risk_amplifiers']:
            if amp['risk'] == 'high':
                score += 5
            elif amp['risk'] == 'medium':
                score += 3
        
        # Security gaps
        score += len(correlations['security_gaps']) * 2
        
        return min(score, 100)  # Cap at 100

# Global instance
vulnerability_correlator = VulnerabilityCorrelator()